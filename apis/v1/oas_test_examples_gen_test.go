// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestChangeKeyStatus_EncodeDecode(t *testing.T) {
	var typ ChangeKeyStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChangeKeyStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChangeKeyStatusStatus_EncodeDecode(t *testing.T) {
	var typ ChangeKeyStatusStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChangeKeyStatusStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateKey_EncodeDecode(t *testing.T) {
	var typ CreateKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDateTime_EncodeDecode(t *testing.T) {
	var typ DateTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DateTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKey_EncodeDecode(t *testing.T) {
	var typ Key
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Key
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyCipher_EncodeDecode(t *testing.T) {
	var typ KeyCipher
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyCipher
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyEncryptAlgoEnum_EncodeDecode(t *testing.T) {
	var typ KeyEncryptAlgoEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyEncryptAlgoEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyOriginEnum_EncodeDecode(t *testing.T) {
	var typ KeyOriginEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyOriginEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyPlain_EncodeDecode(t *testing.T) {
	var typ KeyPlain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyPlain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyServiceClassEnum_EncodeDecode(t *testing.T) {
	var typ KeyServiceClassEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyServiceClassEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyStatusEnum_EncodeDecode(t *testing.T) {
	var typ KeyStatusEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyStatusEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedKeyList_EncodeDecode(t *testing.T) {
	var typ PaginatedKeyList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedKeyList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScheduleDestructionKey_EncodeDecode(t *testing.T) {
	var typ ScheduleDestructionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScheduleDestructionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedChangeKeyStatus_EncodeDecode(t *testing.T) {
	var typ WrappedChangeKeyStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedChangeKeyStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateKey_EncodeDecode(t *testing.T) {
	var typ WrappedCreateKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedKey_EncodeDecode(t *testing.T) {
	var typ WrappedKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedKeyCipher_EncodeDecode(t *testing.T) {
	var typ WrappedKeyCipher
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedKeyCipher
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedKeyPlain_EncodeDecode(t *testing.T) {
	var typ WrappedKeyPlain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedKeyPlain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedScheduleDestructionKey_EncodeDecode(t *testing.T) {
	var typ WrappedScheduleDestructionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedScheduleDestructionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
